/*
 * Akamai: Linode API
 *
 * Add a Cloud Computing instance so you can build, release, and scale applications faster with virtual machines. 
 *
 * The version of the OpenAPI document: 4.193.0
 * Contact: jperez@linode.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct GetLinodeConfigs200ResponseDataInner {
    /// Optional field for arbitrary user comments on this configuration.
    #[serde(rename = "comments", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub comments: Option<Option<String>>,
    #[serde(rename = "devices", skip_serializing_if = "Option::is_none")]
    pub devices: Option<models::GetLinodeConfigs200ResponseDataInnerDevices>,
    #[serde(rename = "helpers", skip_serializing_if = "Option::is_none")]
    pub helpers: Option<models::GetLinodeConfigs200ResponseDataInnerHelpers>,
    /// __Read-only__ The ID of this Config.
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,
    /// An array of Network Interfaces to add to this Linode's Configuration Profile. At least one and up to three Interface objects can exist in this array. The position in the array determines which of the Linode's network Interfaces is configured:  - First [0]:  eth0 - Second [1]: eth1 - Third [2]:  eth2  When updating a Linode's Interfaces, _each Interface must be redefined_. An empty `interfaces` array results in a default `public` type Interface configuration only.  If no public Interface is configured, public IP addresses are still assigned to the Linode but will not be usable without manual configuration.  __Note__. Changes to Linode Interface configurations can be enabled by rebooting the Linode.  `vpc` details  See the [VPC documentation](https://www.linode.com/docs/products/networking/vpc/#technical-specifications) guide for its specifications and limitations.  `vlan` details  - Only Next Generation Network (NGN) data centers support VLANs. Run the [List regions](https://techdocs.akamai.com/linode-api/reference/get-regions) operation to view the capabilities of data center regions. If a VLAN is attached to your Linode and you attempt to migrate or clone it to a non-NGN data center, the migration or cloning will not initiate. If a Linode cannot be migrated or cloned because of an incompatibility, you will be prompted to select a different data center or contact support. - See the [VLANs Overview](https://www.linode.com/docs/products/networking/vlans/#technical-specifications) guide to view additional specifications and limitations.
    #[serde(rename = "interfaces", skip_serializing_if = "Option::is_none")]
    pub interfaces: Option<Vec<models::GetLinodeConfigs200ResponseDataInnerInterfacesInner>>,
    /// The ID of the kernel used to boot a Linode. Run the [List kernels](https://techdocs.akamai.com/linode-api/reference/get-kernels) operation to see all available kernels. Here are some commonly used kernels:  - `linode/latest-64bit`. This is the default, our latest kernel at the time of an instance boot or reboot.  - `linode/grub2`. The upstream distribution-supplied kernel that's installed on the primary disk, or a custom kernel if installed.  - `linode/direct-disk`. The master boot record (MBR) of the primary disk or root device. Use this in place of a Linux kernel.
    #[serde(rename = "kernel", skip_serializing_if = "Option::is_none")]
    pub kernel: Option<String>,
    /// __Filterable__ The name of the configuration for display in Akamai Cloud Manager.
    #[serde(rename = "label", skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Defaults to the total RAM of the Linode.
    #[serde(rename = "memory_limit", skip_serializing_if = "Option::is_none")]
    pub memory_limit: Option<i32>,
    /// The root device to boot.  > ðŸ“˜  - If you leave this empty or set an invalid value, the root device defaults to `/dev/sda`.  - If you specify a device at the root device location and it's not mounted, the Linode won't boot until a device is mounted.
    #[serde(rename = "root_device", skip_serializing_if = "Option::is_none")]
    pub root_device: Option<String>,
    /// Defines the state of your Linode after booting. Defaults to `default`.
    #[serde(rename = "run_level", skip_serializing_if = "Option::is_none")]
    pub run_level: Option<RunLevelEnum>,
    /// Controls the virtualization mode. Defaults to `paravirt`.  - `paravirt` is suitable for most cases. Linodes running in `paravirt` mode share some qualities with the host, ultimately making it run faster since there is less transition between it and the host.  - `fullvirt` affords more customization, but is slower because 100% of the VM is virtualized.
    #[serde(rename = "virt_mode", skip_serializing_if = "Option::is_none")]
    pub virt_mode: Option<VirtModeEnum>,
}

impl GetLinodeConfigs200ResponseDataInner {
    pub fn new() -> GetLinodeConfigs200ResponseDataInner {
        GetLinodeConfigs200ResponseDataInner {
            comments: None,
            devices: None,
            helpers: None,
            id: None,
            interfaces: None,
            kernel: None,
            label: None,
            memory_limit: None,
            root_device: None,
            run_level: None,
            virt_mode: None,
        }
    }
}
/// Defines the state of your Linode after booting. Defaults to `default`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RunLevelEnum {
    #[serde(rename = "default")]
    Default,
    #[serde(rename = "single")]
    Single,
    #[serde(rename = "binbash")]
    Binbash,
}

impl Default for RunLevelEnum {
    fn default() -> RunLevelEnum {
        Self::Default
    }
}
/// Controls the virtualization mode. Defaults to `paravirt`.  - `paravirt` is suitable for most cases. Linodes running in `paravirt` mode share some qualities with the host, ultimately making it run faster since there is less transition between it and the host.  - `fullvirt` affords more customization, but is slower because 100% of the VM is virtualized.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum VirtModeEnum {
    #[serde(rename = "paravirt")]
    Paravirt,
    #[serde(rename = "fullvirt")]
    Fullvirt,
}

impl Default for VirtModeEnum {
    fn default() -> VirtModeEnum {
        Self::Paravirt
    }
}


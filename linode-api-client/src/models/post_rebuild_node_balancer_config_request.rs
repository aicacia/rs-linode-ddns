/*
 * Akamai: Linode API
 *
 * Add a Cloud Computing instance so you can build, release, and scale applications faster with virtual machines. 
 *
 * The version of the OpenAPI document: 4.193.0
 * Contact: jperez@linode.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct PostRebuildNodeBalancerConfigRequest {
    /// The algorithm this HTTPS NodeBalancer uses for routing traffic to backends.
    #[serde(rename = "algorithm", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<AlgorithmEnum>,
    /// The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down.  - If `none` no check is performed. - `connection` requires only a connection to the backend to succeed. - `http` and `http_body` rely on the backend serving HTTP, and that the response returned matches what is expected.
    #[serde(rename = "check", skip_serializing_if = "Option::is_none")]
    pub check: Option<CheckEnum>,
    /// How many times to attempt a check before considering a backend to be down.
    #[serde(rename = "check_attempts", skip_serializing_if = "Option::is_none")]
    pub check_attempts: Option<i32>,
    /// Use when the active health `check` type is `http_body`. This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down.
    #[serde(rename = "check_body", skip_serializing_if = "Option::is_none")]
    pub check_body: Option<String>,
    /// How often, in seconds, to check that backends are up and serving requests.  Must be greater than `check_timeout`.
    #[serde(rename = "check_interval", skip_serializing_if = "Option::is_none")]
    pub check_interval: Option<i32>,
    /// If `true`, any response from this backend with a `5xx` status code will be enough for it to be considered unhealthy and taken out of rotation.
    #[serde(rename = "check_passive", skip_serializing_if = "Option::is_none")]
    pub check_passive: Option<bool>,
    /// The URL path to check on each backend. Use when the active health `check` type is `http`. If the backend doesn't respond to this request, it's considered to be down.
    #[serde(rename = "check_path", skip_serializing_if = "Option::is_none")]
    pub check_path: Option<String>,
    /// How long, in seconds, to wait for a check attempt before considering it failed.  Must be less than `check_interval`.
    #[serde(rename = "check_timeout", skip_serializing_if = "Option::is_none")]
    pub check_timeout: Option<i32>,
    /// What ciphers to use for SSL connections served by this NodeBalancer.  - `legacy` is considered insecure and should only be used if necessary.
    #[serde(rename = "cipher_suite", skip_serializing_if = "Option::is_none")]
    pub cipher_suite: Option<CipherSuiteEnum>,
    /// __Read-only__ This config's unique ID.
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,
    /// __Read-only__ The ID for the NodeBalancer this config belongs to.
    #[serde(rename = "nodebalancer_id", skip_serializing_if = "Option::is_none")]
    pub nodebalancer_id: Option<i32>,
    /// The NodeBalancer nodes that serve this config.  Some considerations for Nodes when rebuilding a config:    - Current Nodes excluded from the request body will be deleted from the Config.   - Current Nodes (identified by their Node ID) will be updated.   - New Nodes (included without a Node ID) will be created.
    #[serde(rename = "nodes")]
    pub nodes: Vec<models::PostRebuildNodeBalancerConfigRequestAllOfNodesInner>,
    #[serde(rename = "nodes_status", skip_serializing_if = "Option::is_none")]
    pub nodes_status: Option<models::TcpNodesStatus>,
    /// This is the port the NodeBalancer listens on for this configuration. Port numbers must be unique across TCP, HTTP, and HTTPS configurations on a single NodeBalancer. However, ports assigned to TCP, HTTP, or HTTPS configurations can also be reused for UDP configurations. For example, Port 80 can simultaneously serve a TCP and a UDP configuration on the same NodeBalancer, but it can't be shared by both a TCP and an HTTP configuration. Although certain ports are traditionally associated with specific protocols, this isn't strictly enforced, and you may configure your NodeBalancer however you find useful.
    #[serde(rename = "port", skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// The protocol the port is configured to serve, `https` in this case.  - The `https` protocol is mutually required with `ssl_cert` and `ssl_key`.  Review our guide on [Available protocols](https://techdocs.akamai.com/cloud-computing/docs/available-protocols) for information on protocol features.
    #[serde(rename = "protocol", skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ProtocolEnum>,
    /// __Read-only__ Not applicable for HTTPS configs.
    #[serde(rename = "proxy_protocol", skip_serializing_if = "Option::is_none")]
    pub proxy_protocol: Option<String>,
    ///  The PEM-formatted public SSL certificate (or the combined PEM-formatted SSL certificate and Certificate Authority chain) that should be served on this NodeBalancerConfig's port.  Line breaks must be represented as `\\n` in the string for requests (but not when using the Linode CLI).  [Diffie-Hellman Parameters](https://www.linode.com/docs/products/networking/nodebalancers/guides/ssl-termination/#diffie-hellman-parameters) can be included in this value to enable forward secrecy.  The contents of this field will not be shown in any responses that display the NodeBalancerConfig. Instead, `<REDACTED>` will be printed where the field appears.  The read-only `ssl_commonname` and `ssl_fingerprint` fields in a NodeBalancerConfig response are automatically derived from your certificate. Please refer to these fields to verify that the appropriate certificate was assigned to your NodeBalancerConfig.
    #[serde(rename = "ssl_cert", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub ssl_cert: Option<Option<String>>,
    /// __Read-only__ The read-only common name automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
    #[serde(rename = "ssl_commonname", skip_serializing_if = "Option::is_none")]
    pub ssl_commonname: Option<String>,
    /// __Read-only__ The read-only SHA1-encoded fingerprint automatically derived from the SSL certificate assigned to this NodeBalancerConfig. Please refer to this field to verify that the appropriate certificate is assigned to your NodeBalancerConfig.
    #[serde(rename = "ssl_fingerprint", skip_serializing_if = "Option::is_none")]
    pub ssl_fingerprint: Option<String>,
    /// The PEM-formatted private key for the SSL certificate set in the `ssl_cert` field.  Line breaks must be represented as `\\n` in the string for requests (but not when using the Linode CLI).  The contents of this field will not be shown in any responses that display the NodeBalancerConfig. Instead, `<REDACTED>` will be printed where the field appears.  The read-only `ssl_commonname` and `ssl_fingerprint` fields in a NodeBalancerConfig response are automatically derived from your certificate. Please refer to these fields to verify that the appropriate certificate was assigned to your NodeBalancerConfig.
    #[serde(rename = "ssl_key", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub ssl_key: Option<Option<String>>,
    /// Controls how session stickiness is handled on this port.  - If set to `none`, connections will always be assigned a backend based on the algorithm configured. - If set to `table`, sessions from the same remote address will be routed to the same backend. - For HTTP or HTTPS clients, `http_cookie` allows sessions to be routed to the same backend based on a cookie set by the NodeBalancer.
    #[serde(rename = "stickiness", skip_serializing_if = "Option::is_none")]
    pub stickiness: Option<StickinessEnum>,
}

impl PostRebuildNodeBalancerConfigRequest {
    pub fn new(nodes: Vec<models::PostRebuildNodeBalancerConfigRequestAllOfNodesInner>) -> PostRebuildNodeBalancerConfigRequest {
        PostRebuildNodeBalancerConfigRequest {
            algorithm: None,
            check: None,
            check_attempts: None,
            check_body: None,
            check_interval: None,
            check_passive: None,
            check_path: None,
            check_timeout: None,
            cipher_suite: None,
            id: None,
            nodebalancer_id: None,
            nodes,
            nodes_status: None,
            port: None,
            protocol: None,
            proxy_protocol: None,
            ssl_cert: None,
            ssl_commonname: None,
            ssl_fingerprint: None,
            ssl_key: None,
            stickiness: None,
        }
    }
}
/// The algorithm this HTTPS NodeBalancer uses for routing traffic to backends.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AlgorithmEnum {
    #[serde(rename = "roundrobin")]
    Roundrobin,
    #[serde(rename = "leastconn")]
    Leastconn,
    #[serde(rename = "source")]
    Source,
}

impl Default for AlgorithmEnum {
    fn default() -> AlgorithmEnum {
        Self::Roundrobin
    }
}
/// The type of check to perform against backends to ensure they are serving requests. This is used to determine if backends are up or down.  - If `none` no check is performed. - `connection` requires only a connection to the backend to succeed. - `http` and `http_body` rely on the backend serving HTTP, and that the response returned matches what is expected.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CheckEnum {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "connection")]
    Connection,
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "http_body")]
    HttpBody,
}

impl Default for CheckEnum {
    fn default() -> CheckEnum {
        Self::None
    }
}
/// What ciphers to use for SSL connections served by this NodeBalancer.  - `legacy` is considered insecure and should only be used if necessary.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CipherSuiteEnum {
    #[serde(rename = "recommended")]
    Recommended,
    #[serde(rename = "legacy")]
    Legacy,
}

impl Default for CipherSuiteEnum {
    fn default() -> CipherSuiteEnum {
        Self::Recommended
    }
}
/// The protocol the port is configured to serve, `https` in this case.  - The `https` protocol is mutually required with `ssl_cert` and `ssl_key`.  Review our guide on [Available protocols](https://techdocs.akamai.com/cloud-computing/docs/available-protocols) for information on protocol features.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProtocolEnum {
    #[serde(rename = "https")]
    Https,
}

impl Default for ProtocolEnum {
    fn default() -> ProtocolEnum {
        Self::Https
    }
}
/// Controls how session stickiness is handled on this port.  - If set to `none`, connections will always be assigned a backend based on the algorithm configured. - If set to `table`, sessions from the same remote address will be routed to the same backend. - For HTTP or HTTPS clients, `http_cookie` allows sessions to be routed to the same backend based on a cookie set by the NodeBalancer.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StickinessEnum {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "table")]
    Table,
    #[serde(rename = "http_cookie")]
    HttpCookie,
}

impl Default for StickinessEnum {
    fn default() -> StickinessEnum {
        Self::None
    }
}


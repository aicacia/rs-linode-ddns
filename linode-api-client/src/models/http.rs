/*
 * Akamai: Linode API
 *
 * Add a Cloud Computing instance so you can build, release, and scale applications faster with virtual machines. 
 *
 * The version of the OpenAPI document: 4.193.0
 * Contact: jperez@linode.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// Http : A NodeBalancer configuration defines the protocol and settings for a specific port on the NodeBalancer. These fields apply to HTTP configurations.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Http {
    /// The algorithm this HTTP NodeBalancer uses for routing traffic to backends.
    #[serde(rename = "algorithm", skip_serializing_if = "Option::is_none")]
    pub algorithm: Option<AlgorithmEnum>,
    /// The type of check to perform against backends to ensure they are serving requests. This determines if backends are up or down.  - If `none`, no check is performed. - `connection` requires only a connection to the backend to succeed. - `http` and `http_body` rely on the backend serving HTTP, and that the response returned matches what is expected.
    #[serde(rename = "check", skip_serializing_if = "Option::is_none")]
    pub check: Option<CheckEnum>,
    /// How many times to attempt a check before considering a backend to be down.
    #[serde(rename = "check_attempts", skip_serializing_if = "Option::is_none")]
    pub check_attempts: Option<i32>,
    /// Use when the active health `check` type is `http_body`. This value must be present in the response body of the check in order for it to pass. If this value is not present in the response body of a check request, the backend is considered to be down.
    #[serde(rename = "check_body", skip_serializing_if = "Option::is_none")]
    pub check_body: Option<String>,
    /// How often, in seconds, to check that backends are up and serving requests.  Must be greater than `check_timeout`.
    #[serde(rename = "check_interval", skip_serializing_if = "Option::is_none")]
    pub check_interval: Option<i32>,
    /// If `true`, any response from this backend with a `5xx` status code will be enough for it to be considered unhealthy and taken out of rotation.
    #[serde(rename = "check_passive", skip_serializing_if = "Option::is_none")]
    pub check_passive: Option<bool>,
    /// The URL path to check on each backend. Use when the active health `check` type is `http`. If the backend doesn't respond to this request, it's considered to be down.
    #[serde(rename = "check_path", skip_serializing_if = "Option::is_none")]
    pub check_path: Option<String>,
    /// How long, in seconds, to wait for a check attempt before considering it failed.  Must be less than `check_interval`.
    #[serde(rename = "check_timeout", skip_serializing_if = "Option::is_none")]
    pub check_timeout: Option<i32>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "cipher_suite", skip_serializing_if = "Option::is_none")]
    pub cipher_suite: Option<String>,
    /// __Read-only__ This config's unique ID.
    #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,
    /// __Read-only__ Identifies the NodeBalancer this config belongs to.
    #[serde(rename = "nodebalancer_id", skip_serializing_if = "Option::is_none")]
    pub nodebalancer_id: Option<i32>,
    /// The NodeBalancer nodes that serve this configuration.
    #[serde(rename = "nodes")]
    pub nodes: Vec<models::TcpHttpOrHttpsConfig>,
    #[serde(rename = "nodes_status", skip_serializing_if = "Option::is_none")]
    pub nodes_status: Option<models::TcpNodesStatus>,
    /// This is the port the NodeBalancer listens on for this configuration. Port numbers need to be unique across TCP, HTTP, and HTTPS configurations on a single NodeBalancer. However, ports assigned to TCP, HTTP, or HTTPS configurations can also be reused for UDP configurations. For example, Port 80 can simultaneously serve a TCP and a UDP configuration on the same NodeBalancer, but it can't be shared by both a TCP and an HTTP configuration. Although certain ports are traditionally associated with specific protocols, this is not strictly enforced. You may configure your NodeBalancer however is useful to you.
    #[serde(rename = "port", skip_serializing_if = "Option::is_none")]
    pub port: Option<i32>,
    /// The protocol the port is configured to serve, `http` in this case. Review our guide on [Available protocols](https://techdocs.akamai.com/cloud-computing/docs/available-protocols) for information on protocol features.
    #[serde(rename = "protocol", skip_serializing_if = "Option::is_none")]
    pub protocol: Option<ProtocolEnum>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "proxy_protocol", skip_serializing_if = "Option::is_none")]
    pub proxy_protocol: Option<String>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "ssl_cert", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub ssl_cert: Option<Option<String>>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "ssl_commonname", skip_serializing_if = "Option::is_none")]
    pub ssl_commonname: Option<String>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "ssl_fingerprint", skip_serializing_if = "Option::is_none")]
    pub ssl_fingerprint: Option<String>,
    /// __Read-only__ Not applicable for HTTP configs.
    #[serde(rename = "ssl_key", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub ssl_key: Option<Option<String>>,
    /// Controls how session stickiness is handled on this port.  - If set to `none`, connections will always be assigned a backend based on the algorithm configured. - If set to `table`, sessions from the same remote address will be routed to the same backend. - If set to `http_cookie`, sessions are routed to the same backend based on a cookie set by the NodeBalancer.
    #[serde(rename = "stickiness", skip_serializing_if = "Option::is_none")]
    pub stickiness: Option<StickinessEnum>,
}

impl Http {
    /// A NodeBalancer configuration defines the protocol and settings for a specific port on the NodeBalancer. These fields apply to HTTP configurations.
    pub fn new(nodes: Vec<models::TcpHttpOrHttpsConfig>) -> Http {
        Http {
            algorithm: None,
            check: None,
            check_attempts: None,
            check_body: None,
            check_interval: None,
            check_passive: None,
            check_path: None,
            check_timeout: None,
            cipher_suite: None,
            id: None,
            nodebalancer_id: None,
            nodes,
            nodes_status: None,
            port: None,
            protocol: None,
            proxy_protocol: None,
            ssl_cert: None,
            ssl_commonname: None,
            ssl_fingerprint: None,
            ssl_key: None,
            stickiness: None,
        }
    }
}
/// The algorithm this HTTP NodeBalancer uses for routing traffic to backends.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum AlgorithmEnum {
    #[serde(rename = "roundrobin")]
    Roundrobin,
    #[serde(rename = "leastconn")]
    Leastconn,
    #[serde(rename = "source")]
    Source,
}

impl Default for AlgorithmEnum {
    fn default() -> AlgorithmEnum {
        Self::Roundrobin
    }
}
/// The type of check to perform against backends to ensure they are serving requests. This determines if backends are up or down.  - If `none`, no check is performed. - `connection` requires only a connection to the backend to succeed. - `http` and `http_body` rely on the backend serving HTTP, and that the response returned matches what is expected.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CheckEnum {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "connection")]
    Connection,
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "http_body")]
    HttpBody,
}

impl Default for CheckEnum {
    fn default() -> CheckEnum {
        Self::None
    }
}
/// The protocol the port is configured to serve, `http` in this case. Review our guide on [Available protocols](https://techdocs.akamai.com/cloud-computing/docs/available-protocols) for information on protocol features.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProtocolEnum {
    #[serde(rename = "http")]
    Http,
}

impl Default for ProtocolEnum {
    fn default() -> ProtocolEnum {
        Self::Http
    }
}
/// Controls how session stickiness is handled on this port.  - If set to `none`, connections will always be assigned a backend based on the algorithm configured. - If set to `table`, sessions from the same remote address will be routed to the same backend. - If set to `http_cookie`, sessions are routed to the same backend based on a cookie set by the NodeBalancer.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StickinessEnum {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "table")]
    Table,
    #[serde(rename = "http_cookie")]
    HttpCookie,
}

impl Default for StickinessEnum {
    fn default() -> StickinessEnum {
        Self::None
    }
}


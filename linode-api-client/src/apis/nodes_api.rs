/*
 * Akamai: Linode API
 *
 * Add a Cloud Computing instance so you can build, release, and scale applications faster with virtual machines. 
 *
 * The version of the OpenAPI document: 4.193.0
 * Contact: jperez@linode.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`delete_lke_cluster_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteLkeClusterNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_node_balancer_config_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNodeBalancerConfigNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_lke_cluster_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLkeClusterNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_node_balancer_config_nodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNodeBalancerConfigNodesError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_node_balancer_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNodeBalancerNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_lke_cluster_node_recycle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostLkeClusterNodeRecycleError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_node_balancer_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostNodeBalancerNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_node_balancer_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutNodeBalancerNodeError {
    DefaultResponse(models::GetAccountDefaultResponse),
    UnknownValue(serde_json::Value),
}


/// Deletes a specific Node from a Node Pool.  __Deleting a Node is a destructive action and cannot be undone.__  Deleting a Node will reduce the size of the Node Pool it belongs to.   <<LB>>  ---   - __CLI__.      ```     linode-cli lke node-delete 12345 12345-6aa78910bc     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     lke:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn delete_lke_cluster_node(configuration: &configuration::Configuration, api_version: &str, cluster_id: i32, node_id: &str) -> Result<serde_json::Value, Error<DeleteLkeClusterNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_cluster_id = cluster_id;
    let p_node_id = node_id;

    let uri_str = format!("{}/{apiVersion}/lke/clusters/{clusterId}/nodes/{nodeId}", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), clusterId=p_cluster_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteLkeClusterNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a Node from this Config. This backend will no longer receive traffic for the configured port of this NodeBalancer.  This does not change or remove the Linode whose address was used in the creation of this Node.   <<LB>>  ---   - __CLI__.      ```     linode-cli nodebalancers node-delete \\   12345 4567 54321     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     nodebalancers:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn delete_node_balancer_config_node(configuration: &configuration::Configuration, api_version: &str, node_balancer_id: i32, config_id: i32, node_id: &str) -> Result<serde_json::Value, Error<DeleteNodeBalancerConfigNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_node_balancer_id = node_balancer_id;
    let p_config_id = config_id;
    let p_node_id = node_id;

    let uri_str = format!("{}/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), nodeBalancerId=p_node_balancer_id, configId=p_config_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteNodeBalancerConfigNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the values for a specified node object.   <<LB>>  ---   - __CLI__.      ```     linode-cli lke node-view 123456 12345-6aa78910bc     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     lke:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn get_lke_cluster_node(configuration: &configuration::Configuration, api_version: &str, cluster_id: i32, node_id: &str) -> Result<models::GetLkeClusterNode200Response, Error<GetLkeClusterNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_cluster_id = cluster_id;
    let p_node_id = node_id;

    let uri_str = format!("{}/{apiVersion}/lke/clusters/{clusterId}/nodes/{nodeId}", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), clusterId=p_cluster_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLkeClusterNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a paginated list of NodeBalancer nodes associated with this Config. These are the backends that will be sent traffic for this port.   <<LB>>  ---   - __CLI__.      ```     linode-cli nodebalancers nodes-list 12345 4567     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     nodebalancers:read_only     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn get_node_balancer_config_nodes(configuration: &configuration::Configuration, api_version: &str, node_balancer_id: i32, config_id: i32, page: Option<i32>, page_size: Option<i32>) -> Result<models::GetNodeBalancerConfigNodes200Response, Error<GetNodeBalancerConfigNodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_node_balancer_id = node_balancer_id;
    let p_config_id = config_id;
    let p_page = page;
    let p_page_size = page_size;

    let uri_str = format!("{}/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), nodeBalancerId=p_node_balancer_id, configId=p_config_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNodeBalancerConfigNodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns information about a single Node, a backend for this NodeBalancer's configured port.   <<LB>>  ---   - __CLI__.      ```     linode-cli nodebalancers node-view 12345 4567 54321     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     nodebalancers:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn get_node_balancer_node(configuration: &configuration::Configuration, api_version: &str, node_balancer_id: i32, config_id: i32, node_id: &str) -> Result<models::GetNodeBalancerConfigNodes200ResponseDataInner, Error<GetNodeBalancerNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_node_balancer_id = node_balancer_id;
    let p_config_id = config_id;
    let p_node_id = node_id;

    let uri_str = format!("{}/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), nodeBalancerId=p_node_balancer_id, configId=p_config_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNodeBalancerNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recycles an individual Node in the designated Kubernetes Cluster. The Node will be deleted and replaced with a new Linode, which may take a few minutes. Replacement Nodes are installed with the latest available patch for the Cluster's Kubernetes Version.  __Any local storage on deleted Linodes (such as `hostPath` and `emptyDir` volumes, or `local` PersistentVolumes) will be erased.__   <<LB>>  ---   - __CLI__.      ```     linode-cli lke node-recycle 12345 12345-6aa78910bc     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     lke:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn post_lke_cluster_node_recycle(configuration: &configuration::Configuration, api_version: &str, cluster_id: i32, node_id: &str) -> Result<serde_json::Value, Error<PostLkeClusterNodeRecycleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_cluster_id = cluster_id;
    let p_node_id = node_id;

    let uri_str = format!("{}/{apiVersion}/lke/clusters/{clusterId}/nodes/{nodeId}/recycle", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), clusterId=p_cluster_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostLkeClusterNodeRecycleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a NodeBalancer node, a backend that can accept traffic for this NodeBalancer Config. Nodes are routed requests on the configured port based on their status.   <<LB>>  ---   - __CLI: TCP, HTTP, HTTPS__.      ```     linode-cli nodebalancers node-create \\   12345 4567 \\   --address 192.168.210.120:80 \\   --label node54321 \\   --weight 50 \\   --mode accept     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     nodebalancers:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn post_node_balancer_node(configuration: &configuration::Configuration, api_version: &str, node_balancer_id: i32, config_id: i32, post_node_balancer_node_request: models::PostNodeBalancerNodeRequest) -> Result<models::GetNodeBalancerConfigNodes200ResponseDataInner, Error<PostNodeBalancerNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_node_balancer_id = node_balancer_id;
    let p_config_id = config_id;
    let p_post_node_balancer_node_request = post_node_balancer_node_request;

    let uri_str = format!("{}/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), nodeBalancerId=p_node_balancer_id, configId=p_config_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_post_node_balancer_node_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PostNodeBalancerNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates information about a Node, a backend for this NodeBalancer's configured port.   <<LB>>  ---   - __CLI: TCP, HTTP, HTTPS__.      ```     linode-cli nodebalancers node-update \\   12345 4567 54321 \\   --address 192.168.210.120:80 \\   --label node54321 \\   --weight 50 \\   --mode accept     ```      [Learn more...](https://techdocs.akamai.com/cloud-computing/docs/getting-started-with-the-linode-cli)  - __OAuth scopes__.      ```     nodebalancers:read_write     ```      [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)
pub async fn put_node_balancer_node(configuration: &configuration::Configuration, api_version: &str, node_balancer_id: i32, config_id: i32, node_id: &str, get_node_balancer_config_nodes200_response_data_inner: models::GetNodeBalancerConfigNodes200ResponseDataInner) -> Result<models::GetNodeBalancerConfigNodes200ResponseDataInner, Error<PutNodeBalancerNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_version = api_version;
    let p_node_balancer_id = node_balancer_id;
    let p_config_id = config_id;
    let p_node_id = node_id;
    let p_get_node_balancer_config_nodes200_response_data_inner = get_node_balancer_config_nodes200_response_data_inner;

    let uri_str = format!("{}/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}", configuration.base_path, apiVersion=crate::apis::urlencode(p_api_version), nodeBalancerId=p_node_balancer_id, configId=p_config_id, nodeId=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_get_node_balancer_config_nodes200_response_data_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PutNodeBalancerNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

